<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cybernetic Fury</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí¢</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        :root {
            --neon-pink: #ff00ff;
            --neon-blue: #00ffff;
            --neon-red: #ff1b1b;
            --background-dark: #0a0a14;
            --text-color: #f0f0f0;
            --asphalt-color: #1a1a2a;
            --reflection-color: rgba(255, 255, 255, 0.05);
        }

        body {
            background-color: var(--background-dark);
            color: var(--text-color);
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            flex-direction: column;
        }

        #game-container {
            width: 100%;
            max-width: 1280px;
            aspect-ratio: 16 / 9;
            position: relative;
            box-shadow: 0 0 20px var(--neon-blue), 0 0 40px var(--neon-pink);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            overflow: hidden;
        }
        
        #background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://raw.githubusercontent.com/MarcusNeves0/CyberFury/refs/heads/main/background.png');
            background-size: cover;
            background-position: center;
            z-index: 0; 
            display: none; /* Escondido por defeito */
        }


        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: var(--background-dark);
            position: relative;
            z-index: 1;
        }

        /* --- Telas de Overlay --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.5s;
            overflow-y: auto;
        }
        
        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            display: none !important;
        }

        #character-selection h1 {
            font-size: 3rem;
            color: var(--neon-pink);
            text-shadow: 0 0 10px var(--neon-pink);
            margin-bottom: 20px;
        }

        .selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            width: 95%;
        }

        .character-card {
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .character-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--neon-pink), 0 0 30px var(--neon-blue);
        }
        
        #select-maliketh {
            border-color: var(--neon-red);
        }
        
        .character-card h2 {
            color: var(--neon-pink);
            font-size: 1.5rem;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .thumbnail-canvas {
            width: 100px;
            height: 100px;
            border: 2px solid var(--neon-blue);
            background-color: var(--asphalt-color);
            margin-bottom: 10px;
            border-radius: 5px;
        }

        #lore-tooltip {
            position: absolute;
            display: none;
            background-color: rgba(0, 0, 10, 0.9);
            border: 1px solid var(--neon-blue);
            color: var(--text-color);
            padding: 10px;
            border-radius: 5px;
            max-width: 250px;
            font-family: sans-serif;
            font-size: 0.9rem;
            pointer-events: none; /* Impede que o tooltip bloqueie eventos do rato */
            z-index: 100;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        /* Loading Screen */
         #loading-screen {
         }

        .loading-controls {
            border: 1px solid var(--neon-blue);
            padding: 25px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            width: 90%; 
            box-sizing: border-box;
        }
        .loading-controls h3 {
             color: var(--neon-blue);
             text-shadow: 0 0 5px var(--neon-blue);
             margin-top: 0;
             font-size: 2.5rem;
             text-align: center;
             margin-bottom: 20px;
        }
        .loading-controls p {
            margin: 10px 0;
            font-family: sans-serif;
            font-size: 1.2rem;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 10px 20px;
        }
        
        /* --- HUD do Jogo --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
        }

        .player-hud {
            width: 45%;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--neon-blue);
        }
        #player2-hud {
            text-align: right;
        }
        
        .player-hud h3 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
        }

        .health-bar-outer, .energy-bar-outer {
            width: 100%;
            height: 20px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 5px;
            margin-top: 5px;
            padding: 2px;
            position: relative; /* Adicionado para posicionamento do texto */
        }
        
        .health-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #aaff00);
            border-radius: 3px;
            transition: width 0.3s;
        }
        
        .energy-bar-inner {
             height: 100%;
             background: linear-gradient(90deg, var(--neon-blue), #00aaff);
             border-radius: 3px;
             transition: width 0.3s;
        }
        
        .bar-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px black;
            font-family: sans-serif;
            font-weight: bold;
        }

        .status-effects {
            min-height: 25px;
            margin-top: 5px;
            display: flex;
            gap: 10px;
        }

        #player2-hud .status-effects {
            justify-content: flex-end;
        }
        
        .status-icon {
            font-size: 20px;
            display: flex;
            align-items: center;
        }

        .status-icon .stack-count {
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
            margin-left: 2px;
        }

        /* --- Tela de Fim de Jogo --- */
        #game-over-screen {
        }
        #game-over-screen button {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            background: var(--neon-blue);
            color: var(--background-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            text-shadow: none;
            transition: all 0.3s;
        }
        #game-over-screen button:hover {
            background-color: var(--neon-pink);
            color: var(--text-color);
            box-shadow: 0 0 15px var(--neon-pink);
        }
        #win-text{
             font-size: 8rem;
             text-shadow: 0 0 20px var(--neon-pink);
        }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="background-layer"></div>
        <div id="character-selection" class="overlay">
            <h1>CYBERNETIC FURY</h1>
            <div class="selection-grid">
                <div class="character-card" id="select-titan" data-lore="Titan foi um grande combatente da guerra que lutou bravamente pelo seu pa√≠s e acabou perdendo muitos amigos. Sendo assim, acabou saindo, pois n√£o estava mais gostando de ter tantas perdas. Hoje em dia, ele luta contra bandidos para proteger sua cidade.">
                    <h2>TITAN</h2>
                    <canvas id="titan-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                <div class="character-card" id="select-spark" data-lore="Spark √© um rob√¥ que foi criado para garantir a seguran√ßa de um laborat√≥rio do governo. Por√©m, em um dia, uma grande explos√£o destruiu todos os outros rob√¥s, fazendo com que apenas ele sobrasse e acabassem abandonando o projeto por falta de recursos. Depois de sair do laborat√≥rio, ele decidiu continuar a lutar, pois todo o seu corpo e ess√™ncia eram feitos para isso.">
                    <h2>SPARK</h2>
                     <canvas id="spark-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                 <div class="character-card" id="select-hades" data-lore="Um heroi de guerra que usava seus poderosos punhos de fogo para enfrentar o inimigo e levalos para conhecer as chamas eternas, quando foi destronado por seus aliados jurou lutar contra todos para voltar ao seu imperio.">
                    <h2>HADES</h2>
                     <canvas id="hades-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                <div class="character-card" id="select-jack" data-lore="Jack ja foi um homem, porem em uma noite de halloween ele acabou caindo em uma maldi√ß√£o que fez sua fantasia de terror ser eternamente grudada ao seu corpo e sendo obrigado a continuar o espirito de dia das bruxas para assustar todos que entrarem em seu caminho.">
                    <h2>JACK</h2>
                     <canvas id="jack-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                <div class="character-card" id="select-genji" data-lore="um lendario espadachin que teve que ver seu irmao ser morto, depois disso jurou matar todos aqueles que estiveram envolvidos no ataque e para isso esta preparado para derramar o quanto de sangue for necess√°rio">
                    <h2>GENJI</h2>
                     <canvas id="genji-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                 <div class="character-card" id="select-ryu" data-lore="n√£o tem muita historia... ele apenas gosta de sair no soco">
                    <h2>RYU</h2>
                     <canvas id="ryu-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                 <div class="character-card" id="select-lorenzo" data-lore="ele perdeu tudo em apostas e acabou tendo que morrar na rua, por√©m um dia o tecnico do maior time da espanha viu ele jogando com uma bola que encontrou na rua e percebeu potencial, depois de entrar para o time se tornou o melhor atacante em menos de 1 ano">
                    <h2>LORENZO</h2>
                     <canvas id="lorenzo-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                 <div class="character-card" id="select-malenia" data-lore="A espada de miquela, ela nunca conheceu a derrota">
                    <h2>MALENIA</h2>
                     <canvas id="malenia-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
                 <div class="character-card" id="select-maliketh" data-lore="Maliketh √© a leal Besta Presa nas Sombras e meio-irm√£o da Rainha Marika, a Eterna, uma Emp√≠rea de ascend√™ncia Numen, que se tornaria o recipiente do Elden Ring">
                    <h2>MALIKETH</h2>
                     <canvas id="maliketh-thumbnail" class="thumbnail-canvas"></canvas>
                </div>
            </div>
             <div id="lore-tooltip" class="hidden"></div>
        </div>
        
        <div id="loading-screen" class="overlay hidden">
            <div class="loading-controls">
                <h3>Controles</h3>
                <div class="controls-grid">
                    <p><strong>Movimento:</strong> A, D</p>
                     <p><strong>Pulo:</strong> Espa√ßo</p>
                    <p><strong>Defesa:</strong> Segurar S</p>
                    <p><strong>Soco B√°sico:</strong> Seta Esquerda</p>
                    <p><strong>Ataque Especial:</strong> Seta Direita</p>
                    <p><strong>Soco Forte:</strong> Frente, Frente + Seta Esq.</p>
                </div>
            </div>
        </div>

        <div id="game-over-screen" class="overlay hidden">
            <span id="win-text"></span>
            <button id="restart-button">Jogar Novamente</button>
        </div>

        <div id="hud">
            <div id="player1-hud" class="player-hud">
                <h3 id="p1-name">JOGADOR 1</h3>
                <div class="health-bar-outer">
                    <div id="p1-health" class="health-bar-inner"></div>
                    <span id="p1-health-text" class="bar-text"></span>
                </div>
                <div class="energy-bar-outer">
                    <div id="p1-energy" class="energy-bar-inner"></div>
                    <span id="p1-energy-text" class="bar-text"></span>
                </div>
                 <div id="p1-status-effects" class="status-effects"></div>
            </div>
            <div id="player2-hud" class="player-hud">
                <h3 id="p2-name">COMPUTADOR</h3>
                 <div class="health-bar-outer">
                    <div id="p2-health" class="health-bar-inner"></div>
                    <span id="p2-health-text" class="bar-text"></span>
                </div>
                <div class="energy-bar-outer">
                    <div id="p2-energy" class="energy-bar-inner"></div>
                    <span id="p2-energy-text" class="bar-text"></span>
                </div>
                 <div id="p2-status-effects" class="status-effects"></div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

<script>
    // --- Fun√ß√µes de Desenho dos Personagens ---
    function drawTitanArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;
        const attackType = fighter ? fighter.attackBox.type : null;

        const skinTone = '#f2d2b4';
        const skinShadow = '#d3a180';
        const shortsColor = '#1e90ff';
        const shortsStripe = '#fff';
        const capColor = '#ff4141';
        const shoeColor = '#4169e1';
        const robotArmColor = '#a0a0a0';
        const robotArmDark = '#707070';
        
        ctx.fillStyle = shoeColor;
        ctx.fillRect(x + pixel, y + pixel * 11, pixel * 2, pixel);
        ctx.fillRect(x + pixel * 4, y + pixel * 11, pixel * 2, pixel);
        
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 7, pixel * 1.5, pixel * 4);
        ctx.fillRect(x + pixel * 4, y + pixel * 7, pixel * 1.5, pixel * 4);
        ctx.fillStyle = skinShadow;
        ctx.fillRect(x + pixel * 2.5, y + pixel * 7, pixel * 0.5, pixel * 4);
        ctx.fillRect(x + pixel * 5, y + pixel * 7, pixel * 0.5, pixel * 4);

        ctx.fillStyle = shortsColor;
        ctx.fillRect(x + pixel * 1, y + pixel * 5, pixel * 5, pixel * 3);
        ctx.fillStyle = shortsStripe;
        ctx.fillRect(x + pixel * 1, y + pixel * 5, pixel * 0.5, pixel * 3);

        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 0.5, y + pixel * 3, pixel * 1.5, pixel * 3);
        ctx.fillStyle = skinShadow;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 3, pixel * 0.5, pixel * 3);

        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 2, y + pixel * 2, pixel * 3, pixel * 4);
        ctx.fillStyle = skinShadow;
        ctx.fillRect(x + pixel * 2.8, y + pixel * 2, pixel * 0.4, pixel * 4);
        ctx.fillRect(x + pixel * 2, y + pixel * 3, pixel * 3, pixel * 0.4);
        ctx.fillRect(x + pixel * 2, y + pixel * 4, pixel * 3, pixel * 0.4);
        ctx.fillRect(x + pixel * 2, y + pixel * 5, pixel * 3, pixel * 0.4);
        
        ctx.fillStyle = robotArmColor;
        if(isAttacking && (attackType === 'punch' || attackType === 'strong_punch')) {
            ctx.fillRect(x + pixel * 5, y + pixel * 3.5, pixel * 3, pixel * 2);
        } else {
            ctx.fillRect(x + pixel * 5, y + pixel * 3, pixel * 2, pixel * 4);
        }
        ctx.fillStyle = robotArmDark;
        ctx.fillRect(x + pixel * 5, y + pixel * 4, pixel * 2, pixel * 0.5);
        ctx.fillRect(x + pixel * 5, y + pixel * 6, pixel * 2, pixel * 0.5);
         
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 2, y, pixel * 3, pixel * 2.5);
        ctx.fillStyle = capColor;
        ctx.fillRect(x + pixel * 1.5, y - pixel * 0.5, pixel * 4, pixel);
        ctx.fillRect(x + pixel * 4, y, pixel * 1.5, pixel * 1.5);
    }
    
    function drawSparkArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;

        const darkGrey = '#555';
        const lightGrey = '#808080';
        const capeColor = '#222';
        const shoeColor = '#D92626';
        const shoeSole = '#FFF';
        const chestOrange = '#ff8c00';
        const chestYellow = '#ffae42';
        const eyeColor = '#ff4500';

        ctx.fillStyle = capeColor;
        ctx.beginPath();
        ctx.moveTo(x + pixel * 3, y + pixel * 2);
        ctx.lineTo(x, y + pixel * 11);
        ctx.lineTo(x + pixel * 2, y + pixel * 11.5);
        ctx.lineTo(x + pixel * 5, y + pixel * 3);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = shoeColor;
        ctx.fillRect(x + pixel * 0.5, y + pixel * 11, pixel * 2, pixel);
        ctx.fillRect(x + pixel * 3.5, y + pixel * 11, pixel * 2, pixel);
        ctx.fillStyle = shoeSole;
        ctx.fillRect(x + pixel * 0.5, y + pixel * 11.7, pixel * 2, pixel * 0.3);
        ctx.fillRect(x + pixel * 3.5, y + pixel * 11.7, pixel * 2, pixel * 0.3);
        
        ctx.fillStyle = lightGrey;
        ctx.fillRect(x + pixel, y + pixel * 7, pixel, pixel * 4);
        ctx.fillRect(x + pixel * 4, y + pixel * 7, pixel, pixel * 4);
        ctx.fillStyle = darkGrey;
        ctx.fillRect(x + pixel, y + pixel * 9, pixel, pixel * 0.5);
        ctx.fillRect(x + pixel * 4, y + pixel * 9, pixel, pixel * 0.5);
        
        ctx.fillStyle = lightGrey;
        ctx.fillRect(x + pixel * 2, y + pixel * 4, pixel * 2, pixel * 3);
        ctx.fillStyle = darkGrey;
        ctx.fillRect(x + pixel * 2, y + pixel * 5, pixel * 2, pixel * 0.3);
        ctx.fillRect(x + pixel * 2, y + pixel * 6, pixel * 2, pixel * 0.3);

        ctx.fillStyle = chestOrange;
        ctx.beginPath();
        ctx.arc(x + pixel * 3, y + pixel * 4.5, pixel * 1.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = chestYellow;
        ctx.beginPath();
        ctx.arc(x + pixel * 3, y + pixel * 4.5, pixel * 0.8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = lightGrey;
        ctx.fillRect(x + pixel, y + pixel * 4, pixel, pixel * 3);
        ctx.fillStyle = darkGrey;
        ctx.fillRect(x + pixel, y + pixel * 5.5, pixel, pixel * 0.5);
        
        ctx.fillStyle = lightGrey;
        if(isAttacking) {
             ctx.fillRect(x + pixel * 4, y + pixel * 4, pixel * 2.5, pixel);
        } else {
             ctx.fillRect(x + pixel * 4, y + pixel * 4, pixel, pixel * 3);
        }
        ctx.fillStyle = darkGrey;
        ctx.fillRect(x + pixel * 4, y + pixel * 5.5, pixel, pixel * 0.5);
        
        ctx.fillStyle = capeColor;
        ctx.fillRect(x + pixel, y, pixel * 4, pixel * 2.5);
        ctx.fillStyle = lightGrey;
        ctx.fillRect(x + pixel * 2, y + pixel, pixel * 2, pixel * 2);
        ctx.fillStyle = eyeColor;
        ctx.fillRect(x + pixel * 2.2, y + pixel * 1.5, pixel * 1.6, pixel * 0.5);
    }

    function drawHadesArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;

        const skinTone = '#8d5524';
        const skinShadow = '#653d1b';
        const pantsColor = '#404040';
        const beltColor = '#202020';
        
        ctx.fillStyle = pantsColor;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 7, pixel * 1.5, pixel * 5); // Esquerda
        ctx.fillRect(x + pixel * 4, y + pixel * 7, pixel * 1.5, pixel * 5); // Direita
        
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel, y + pixel * 2, pixel * 5, pixel * 5);
        ctx.fillStyle = skinShadow;
        ctx.fillRect(x + pixel*2.8, y + pixel * 2, pixel * 0.4, pixel*5);
        ctx.fillRect(x + pixel, y + pixel * 3, pixel * 5, pixel * 0.4);
        ctx.fillRect(x + pixel, y + pixel * 4.5, pixel * 5, pixel * 0.4);
        
        ctx.fillStyle = beltColor;
        ctx.fillRect(x + pixel, y + pixel * 6.5, pixel * 5, pixel);

        ctx.fillStyle = 'orange';
        if (isAttacking) {
             ctx.fillRect(x + pixel * 5, y + pixel * 3, pixel * 2, pixel * 2);
             ctx.fillStyle = 'red';
             ctx.fillRect(x + pixel * 5.5, y + pixel * 3.5, pixel, pixel);
        } else {
             ctx.fillRect(x + pixel * 0.5, y + pixel * 3, pixel, pixel);
             ctx.fillRect(x + pixel * 5.5, y + pixel * 3, pixel, pixel);
        }

        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 0.5, y + pixel * 4, pixel, pixel*2);
        ctx.fillRect(x + pixel * 5.5, y + pixel * 4, pixel, pixel*2);

        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 2, y, pixel * 3, pixel * 2.5);
        ctx.fillStyle = '#000';
        ctx.fillRect(x + pixel, y, pixel*5, pixel*0.5); // Cabelo
    }
    
    function drawJackArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;

        const hoodieColor = '#1a1a1a';
        const pantsColor = '#2a2a2a';
        const shoeColor = '#e74c3c';
        const pumpkinColor = '#f39c12';
        const pumpkinShadow = '#e67e22';
        const pumpkinEye = '#f1c40f';

        // P√©s
        ctx.fillStyle = shoeColor;
        ctx.fillRect(x + pixel, y + pixel * 11, pixel * 2, pixel);
        ctx.fillRect(x + pixel * 4, y + pixel * 11, pixel * 2, pixel);
        
        // Cal√ßas
        ctx.fillStyle = pantsColor;
        ctx.fillRect(x + pixel*1.5, y + pixel * 7, pixel, pixel*4);
        ctx.fillRect(x + pixel*4.5, y + pixel * 7, pixel, pixel*4);

        // Hoodie
        ctx.fillStyle = hoodieColor;
        ctx.fillRect(x + pixel, y + pixel * 4, pixel * 5, pixel*4);
        // Bra√ßos
        ctx.fillRect(x + pixel*0.5, y + pixel*5, pixel, pixel*3);
        if (isAttacking) {
            ctx.fillRect(x + pixel*5.5, y + pixel*5, pixel*2, pixel);
        } else {
            ctx.fillRect(x + pixel*5.5, y + pixel*5, pixel, pixel*3);
        }
        
        // Cabe√ßa de Ab√≥bora
        ctx.fillStyle = pumpkinColor;
        ctx.fillRect(x + pixel, y, pixel * 5, pixel*4);
        ctx.fillStyle = pumpkinShadow;
        ctx.fillRect(x + pixel*1.5, y + pixel, pixel, pixel*0.5); // Olho esquerdo
        ctx.fillRect(x + pixel*4.5, y + pixel, pixel, pixel*0.5); // Olho direito
        ctx.fillRect(x + pixel*3, y + pixel*2, pixel, pixel*0.5); // Nariz
        ctx.fillRect(x + pixel*2, y + pixel*3, pixel*3, pixel*0.5); // Boca

        ctx.fillStyle = pumpkinEye;
        ctx.fillRect(x + pixel*1.7, y + pixel*1.2, pixel*0.6, pixel*0.2);
        ctx.fillRect(x + pixel*4.7, y + pixel*1.2, pixel*0.6, pixel*0.2);

    }
    
     function drawGenjiArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;
        const attackType = fighter ? fighter.attackBox.type : null;

        const humanColor = '#f2d2b4';
        const robotColor = '#333';
        const helmetColor = '#95a5a6';
        const eyeColor = '#2ecc71';
        const fireCircleColor = '#e67e22';
        const bladeColor = '#7fffd4';

        // Perna rob√≥tica (frente)
        ctx.fillStyle = robotColor;
        ctx.fillRect(x + pixel * 4, y + pixel * 7, pixel * 1.5, pixel * 5);
        // Perna humana (atr√°s)
        ctx.fillStyle = humanColor;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 7, pixel * 1.5, pixel * 5);
        
        // Torso (meio a meio)
        ctx.fillStyle = robotColor;
        ctx.fillRect(x + pixel * 3, y + pixel * 2, pixel * 2, pixel * 5);
        ctx.fillStyle = humanColor;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 2, pixel * 1.5, pixel * 5);
        
        // C√≠rculos de fogo
        ctx.fillStyle = fireCircleColor;
        ctx.beginPath();
        ctx.arc(x + pixel * 3.5, y + pixel * 3, pixel * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + pixel * 3.5, y + pixel * 4.5, pixel * 0.5, 0, Math.PI * 2);
        ctx.fill();
         ctx.beginPath();
        ctx.arc(x + pixel * 3.5, y + pixel * 6, pixel * 0.5, 0, Math.PI * 2);
        ctx.fill();


        // Bra√ßo rob√≥tico (frente) & Espada
        ctx.fillStyle = robotColor;
        if(isAttacking) {
            ctx.fillRect(x + pixel * 5, y + pixel * 3.5, pixel * 1.5, pixel * 1.5); // Punho
            ctx.fillStyle = bladeColor;
            ctx.shadowColor = bladeColor;
            ctx.shadowBlur = 10;
            ctx.fillRect(x + pixel * 6.5, y + pixel * 4, pixel * 4, pixel * 0.5);
            ctx.shadowBlur = 0;
        } else {
            ctx.fillRect(x + pixel * 5, y + pixel * 3, pixel * 1.5, pixel * 3);
        }

        // Bra√ßo humano (atr√°s)
        ctx.fillStyle = humanColor;
        ctx.fillRect(x + pixel * 0.5, y + pixel * 3, pixel, pixel * 3);


        // Capacete
        ctx.fillStyle = helmetColor;
        ctx.fillRect(x + pixel, y, pixel * 4.5, pixel * 2.5);
        ctx.fillStyle = eyeColor;
        ctx.fillRect(x + pixel * 2, y + pixel, pixel * 2, pixel * 0.5);
    }

    function drawRyuArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;

        const skinTone = '#f2d2b4';
        const skinShadow = '#d3a180';
        const kimonoColor = '#ffffff';
        const kimonoShadow = '#e0e0e0';
        const bandColor = '#ff0000';
        
        // P√©s
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 11, pixel * 1.5, pixel);
        ctx.fillRect(x + pixel * 4, y + pixel * 11, pixel * 1.5, pixel);

        // Pernas
        ctx.fillStyle = kimonoColor;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 7, pixel * 1.5, pixel * 4); // Esquerda
        ctx.fillRect(x + pixel * 4, y + pixel * 7, pixel * 1.5, pixel * 4); // Direita
        
        // Torso
        ctx.fillStyle = kimonoColor;
        ctx.fillRect(x + pixel, y + pixel * 2, pixel * 5, pixel * 5);
        ctx.fillStyle = kimonoShadow;
        ctx.fillRect(x + pixel * 2.8, y + pixel * 2, pixel * 0.4, pixel * 5);
        
        // Faixa da cintura
        ctx.fillStyle = bandColor;
        ctx.fillRect(x + pixel, y + pixel * 6.5, pixel * 5, pixel);

        // Bra√ßos
        ctx.fillStyle = skinTone;
        if (isAttacking) {
            ctx.fillRect(x + pixel * 5, y + pixel * 3, pixel * 2, pixel * 1.5);
        } else {
            ctx.fillRect(x + pixel * 5.5, y + pixel * 4, pixel, pixel*2);
        }
        ctx.fillRect(x + pixel * 0.5, y + pixel * 4, pixel, pixel*2);


        // Cabe√ßa
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 2, y, pixel * 3, pixel * 2.5);
        ctx.fillStyle = bandColor;
        ctx.fillRect(x + pixel, y + pixel*0.5, pixel * 5, pixel * 0.5);
    }
    
    function drawDonLorenzoArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;
        
        const uniformColor = '#ffffff';
        const skinTone = '#f2d2b4';
        const shoeColor = '#000000';
        const roseColor = '#3498db';

        // P√©s
        ctx.fillStyle = shoeColor;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 11, pixel * 2, pixel);
        ctx.fillRect(x + pixel * 4.5, y + pixel * 11, pixel * 2, pixel);

        // Pernas
        ctx.fillStyle = uniformColor;
        ctx.fillRect(x + pixel * 2, y + pixel * 7, pixel, pixel*4);
        ctx.fillRect(x + pixel * 4, y + pixel * 7, pixel, pixel*4);

        // Camisa
        ctx.fillRect(x + pixel * 1.5, y + pixel * 3, pixel*4, pixel*4);
        
        // Rosa
        ctx.fillStyle = roseColor;
        ctx.beginPath();
        ctx.arc(x + pixel * 2.5, y + pixel * 4, pixel*0.5, 0, Math.PI * 2);
        ctx.fill();

        // Bra√ßos
        ctx.fillStyle = skinTone;
        if(isAttacking) {
            ctx.fillRect(x + pixel * 5.5, y + pixel * 4, pixel * 2, pixel);
        } else {
            ctx.fillRect(x + pixel * 5.5, y + pixel * 4, pixel, pixel*3);
        }
        ctx.fillRect(x + pixel, y + pixel * 4, pixel, pixel*3);
        
        // Cabe√ßa
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel*2, y, pixel * 3, pixel*3);
        ctx.fillStyle = '#000'; // Cabelo
        ctx.fillRect(x+pixel*2, y, pixel*3, pixel);
    }
    
    function drawMaleniaArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;

        const armorGold = '#c9a46a';
        const capeRed = '#a13a3a';
        const hairRed = '#e54b4b';
        const bladeColor = '#d4af37';
        const skinTone = '#f2d2b4';

        // P√©s e pernas
        ctx.fillStyle = armorGold;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 10, pixel, pixel * 2);
        ctx.fillRect(x + pixel * 4.5, y + pixel * 10, pixel, pixel * 2);

        // Saia e armadura do torso
        ctx.fillStyle = '#8b7355';
        ctx.fillRect(x + pixel, y + pixel * 6, pixel * 5, pixel * 4);
        ctx.fillStyle = armorGold;
        ctx.fillRect(x + pixel * 1.5, y + pixel * 4, pixel * 4, pixel * 3);
        
        // Capa
        ctx.fillStyle = capeRed;
        ctx.beginPath();
        ctx.moveTo(x + pixel * 0.5, y + pixel * 2);
        ctx.lineTo(x - pixel, y + height);
        ctx.lineTo(x + pixel * 2, y + height);
        ctx.closePath();
        ctx.fill();

        // Bra√ßos e espada
        ctx.fillStyle = skinTone;
        ctx.fillRect(x + pixel * 0.5, y + pixel * 5, pixel, pixel * 3); // Bra√ßo esquerdo
        ctx.fillStyle = armorGold;
        ctx.fillRect(x + pixel * 5.5, y + pixel * 5, pixel, pixel * 4); // Bra√ßo direito (pr√≥tese)
        
        ctx.fillStyle = bladeColor;
        if (isAttacking) {
             ctx.fillRect(x + pixel * 6.5, y + pixel * 5.5, pixel * 4, pixel * 0.5);
        } else {
             ctx.fillRect(x + pixel * 5.5, y + pixel * 9, pixel, pixel * 3);
        }

        // Cabe√ßa e cabelo
        ctx.fillStyle = hairRed;
        ctx.fillRect(x + pixel * 1.5, y - pixel, pixel * 4, pixel * 4);
        ctx.fillStyle = armorGold;
        ctx.fillRect(x + pixel * 1, y, pixel * 5, pixel * 2.5); // Elmo
        ctx.fillStyle = '#000';
        ctx.fillRect(x + pixel * 2, y + pixel, pixel * 3, pixel * 0.5); // Visor
    }

    function drawMalikethArt(ctx, x, y, width, height, fighter) {
        const pixel = height / 12;
        const isAttacking = fighter ? fighter.isAttacking : false;
        const isTransformed = fighter ? fighter.isTransformed : false;

        const armorColor = '#222';
        const hairColor = '#fff';
        const bladeColor = '#ff0000';

        if (isTransformed) {
            ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
            ctx.shadowBlur = 20;
        }

        // P√©s
        ctx.fillStyle = armorColor;
        ctx.fillRect(x, y + pixel * 11, pixel * 2, pixel);
        ctx.fillRect(x + pixel * 5, y + pixel * 11, pixel * 2, pixel);

        // Pernas
        ctx.fillRect(x + pixel, y + pixel * 7, pixel * 1.5, pixel * 4);
        ctx.fillRect(x + pixel * 4.5, y + pixel * 7, pixel * 1.5, pixel * 4);
        
        // Corpo
        ctx.fillRect(x + pixel * 1, y + pixel * 4, pixel * 5, pixel * 4);

        // Cabelo
        ctx.fillStyle = hairColor;
        ctx.fillRect(x, y + pixel * 2, pixel * 7, pixel * 3);

        // Espada
        ctx.fillStyle = bladeColor;
        if(isAttacking) {
            ctx.shadowColor = bladeColor;
            ctx.shadowBlur = 15;
            ctx.fillRect(x - pixel * 2, y + pixel * 2, pixel, pixel * 8);
        } else {
            ctx.fillRect(x + pixel * 6, y + pixel * 3, pixel, pixel * 8);
        }
        ctx.shadowBlur = 0;
    }
    
    function drawThumbnails(){
        const titanCanvas = document.getElementById('titan-thumbnail');
        const titanCtx = titanCanvas.getContext('2d');
        titanCanvas.width = 120;
        titanCanvas.height = 120;
        drawTitanArt(titanCtx, 30, 0, 60, 120, null);
        
        const sparkCanvas = document.getElementById('spark-thumbnail');
        const sparkCtx = sparkCanvas.getContext('2d');
        sparkCanvas.width = 120;
        sparkCanvas.height = 120;
        drawSparkArt(sparkCtx, 30, 0, 60, 120, null);

        const hadesCanvas = document.getElementById('hades-thumbnail');
        const hadesCtx = hadesCanvas.getContext('2d');
        hadesCanvas.width = 120;
        hadesCanvas.height = 120;
        drawHadesArt(hadesCtx, 30, 0, 60, 120, null);
        
        const jackCanvas = document.getElementById('jack-thumbnail');
        const jackCtx = jackCanvas.getContext('2d');
        jackCanvas.width = 120;
        jackCanvas.height = 120;
        drawJackArt(jackCtx, 30, 0, 60, 120, null);
        
        const genjiCanvas = document.getElementById('genji-thumbnail');
        const genjiCtx = genjiCanvas.getContext('2d');
        genjiCanvas.width = 120;
        genjiCanvas.height = 120;
        drawGenjiArt(genjiCtx, 30, 0, 60, 120, null);

        const ryuCanvas = document.getElementById('ryu-thumbnail');
        const ryuCtx = ryuCanvas.getContext('2d');
        ryuCanvas.width = 120;
        ryuCanvas.height = 120;
        drawRyuArt(ryuCtx, 30, 0, 60, 120, null);
        
        const lorenzoCanvas = document.getElementById('lorenzo-thumbnail');
        const lorenzoCtx = lorenzoCanvas.getContext('2d');
        lorenzoCanvas.width = 120;
        lorenzoCanvas.height = 120;
        drawDonLorenzoArt(lorenzoCtx, 30, 0, 60, 120, null);
        
        const maleniaCanvas = document.getElementById('malenia-thumbnail');
        const maleniaCtx = maleniaCanvas.getContext('2d');
        maleniaCanvas.width = 120;
        maleniaCanvas.height = 120;
        drawMaleniaArt(maleniaCtx, 30, 0, 60, 120, null);
        
        const malikethCanvas = document.getElementById('maliketh-thumbnail');
        const malikethCtx = malikethCanvas.getContext('2d');
        malikethCanvas.width = 120;
        malikethCanvas.height = 120;
        drawMalikethArt(malikethCtx, 30, 0, 60, 120, null);
    }

window.onload = () => {
    // --- Configura√ß√µes Iniciais ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const selectionScreen = document.getElementById('character-selection');
    const loadingScreen = document.getElementById('loading-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const winText = document.getElementById('win-text');
    const restartButton = document.getElementById('restart-button');
    const backgroundLayer = document.getElementById('background-layer');

    let canvasWidth, canvasHeight;
    let gameLoopId;
    let gameState = 'SELECT'; // SELECT, FIGHT, GAMEOVER

    // --- Entidades do Jogo ---
    let player1, player2, particles = [], projectiles = [];
    const gravity = 0.7;
    let floorY;
    let groundFootball = null;
    let giantBall = null;

    // --- Redimensionamento do Canvas ---
    function resizeCanvas() {
        canvasWidth = gameContainer.clientWidth;
        canvasHeight = gameContainer.clientHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        floorY = canvasHeight * 0.9;
        
        if (gameState !== 'SELECT') {
            drawBackground();
        }
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // --- √Åudio com Tone.js ---
    const sounds = {
        spark: {
            punch: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 4, options: { volume: -12, oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } } }).toDestination(),
            strong_punch: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 4, options: { oscillator: { type: 'fmsquare' }, volume: -10, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } } }).toDestination(),
            special: new Tone.NoiseSynth({ noise: {type: "pink"}, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01 } }).toDestination(),
        },
        titan: {
            punch: new Tone.PolySynth(Tone.MembraneSynth, { maxPolyphony: 4, options: { volume: -10, pitchDecay: 0.05, octaves: 10, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } } }).toDestination(),
            strong_punch: new Tone.PolySynth(Tone.MembraneSynth, { maxPolyphony: 4, options: { volume: -8, pitchDecay: 0.1, octaves: 8, envelope: { attack: 0.01, decay: 0.5, sustain: 0.02, release: 1.4, attackCurve: 'exponential' } } }).toDestination(),
            special: new Tone.PolySynth(Tone.NoiseSynth, { maxPolyphony: 2, options: { volume: -10, noise: { type: 'white' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.3 } } }).toDestination(),
        },
         hades: {
            punch: new Tone.PolySynth(Tone.FMSynth, { maxPolyphony: 4, options: { volume: -12, harmonicity: 1.5, modulationIndex: 2, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } } }).toDestination(),
            strong_punch: new Tone.PolySynth(Tone.FMSynth, { maxPolyphony: 4, options: { volume: -10, harmonicity: 2, modulationIndex: 5, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } } }).toDestination(),
            special: new Tone.PolySynth(Tone.NoiseSynth, { maxPolyphony: 2, options: { noise: { type: 'brown' }, volume: -8, envelope: { attack: 0.05, decay: 0.4, sustain: 0.1, release: 0.3 } } }).toDestination(),
        },
        jack: {
            punch: new Tone.PolySynth(Tone.AMSynth, { maxPolyphony: 4, options: { volume: -12, harmonicity: 1.2, envelope: { attack: 0.05, decay: 0.3, sustain: 0, release: 0.1 } } }).toDestination(),
            strong_punch: new Tone.PolySynth(Tone.AMSynth, { maxPolyphony: 4, options: { volume: -10, harmonicity: 1.5, envelope: { attack: 0.05, decay: 0.5, sustain: 0, release: 0.2 } } }).toDestination(),
            special: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 2, options: { oscillator: { type: 'sawtooth' }, volume: -8, envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.4 } } }).toDestination(),
        },
        genji: {
            punch: new Tone.PolySynth(Tone.PluckSynth, { maxPolyphony: 4, options: { volume: -10, attackNoise: 0.5, dampening: 2000, resonance: 0.9 } }).toDestination(),
            strong_punch: new Tone.PolySynth(Tone.PluckSynth, { maxPolyphony: 4, options: { volume: -8, attackNoise: 1, dampening: 1500, resonance: 0.95 } }).toDestination(),
            special: new Tone.PolySynth(Tone.NoiseSynth, { maxPolyphony: 2, options: { noise: { type: 'white' }, volume: -6, envelope: { attack: 0.2, decay: 1.0, sustain: 0, release: 0.5 } } }).toDestination(),
        },
        ryu: {
            punch: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8, options: { volume: -14, oscillator: {type: "sine"}, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } } }).toDestination(),
            strong_punch: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 4, options: { volume: -10, oscillator: {type: "triangle"}, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } } }).toDestination(),
            special: new Tone.PolySynth(Tone.NoiseSynth, { maxPolyphony: 2, options: { noise: {type: "white"}, volume: -8, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } } }).toDestination(),
        },
        defenseBreak: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 1, options: { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } } }).toDestination(),

    };
    sounds.spark.special.volume.value = -15;

    // --- Classes do Jogo ---

    class Projectile {
        constructor(x, y, direction, shooter, type, damage) {
            this.shooter = shooter;
            this.type = type; 
            this.damage = damage;
            this.hitTargets = [];
            
            if(type === 'pumpkin') {
                this.width = 120;
                this.height = 120;
            } else {
                this.width = 40;
                this.height = 40;
            }

            this.position = { x: x, y: y };
            this.velocity = { x: direction * 8, y: 0 }; 
            this.direction = direction;
            this.isReturning = false;
        }

        draw() {
            let fontSize = 40;
            if(this.type === 'pumpkin') {
                fontSize = 120;
            }
            ctx.font = `${fontSize}px sans-serif`;
            ctx.textBaseline = 'middle';
            
            ctx.save();
            ctx.translate(this.position.x + this.width / 2, this.position.y + this.height / 2);

            if (this.type === 'rocket_punch') {
                if (this.direction === -1) {
                    ctx.scale(-1, 1);
                }
                ctx.fillText('üöÄ', -this.width / 2, 0);
            } else if (this.type === 'pumpkin') {
                ctx.fillText('üéÉ', -this.width / 2, 0);
            } else if (this.type === 'tornado') {
                ctx.fillText('üå™Ô∏è', -this.width / 2, 0);
            } else if (this.type === 'football') {
                ctx.fillText('‚öΩÔ∏è', -this.width / 2, 0);
            } else if (this.type === 'maliketh_blade') {
                ctx.font = `30px sans-serif`;
                ctx.fillText('üí•', -this.width / 2, 0);
            }
            
            ctx.restore();
        }

        update() {
            if (this.isReturning) {
                const dx = this.shooter.position.x + this.shooter.width / 2 - (this.position.x + this.width / 2);
                const dy = this.shooter.position.y + this.shooter.height / 2 - (this.position.y + this.height / 2);
                const angle = Math.atan2(dy, dx);
                const returnSpeed = 4; // Velocidade de retorno reduzida
                this.velocity.x = Math.cos(angle) * returnSpeed;
                this.velocity.y = Math.sin(angle) * returnSpeed;
            }
            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;
        }
    }

     class GiantBall {
        constructor(x, y, direction, owner) {
            this.owner = owner;
            this.position = { x, y };
            this.velocity = { x: direction * 2 };
            this.width = 120;
            this.height = 120;
            this.health = 4;
            this.damageTick = 0;
        }

        update(opponent) {
            this.position.x += this.velocity.x;
            
            if (this.position.x + this.width > canvasWidth || this.position.x < 0) {
                this.velocity.x *= -1;
            }
            
            if(isColliding(this, opponent)){
                opponent.position.x += this.velocity.x;
                this.damageTick++;
                if(this.damageTick >= 60){
                    opponent.takeDamage(80);
                    this.damageTick = 0;
                }
                
                if(opponent.position.x <= 0 || opponent.position.x + opponent.width >= canvasWidth){
                    this.explode(opponent);
                }
            }
        }

        draw() {
            ctx.font = '120px sans-serif';
            ctx.fillText('‚öΩÔ∏è', this.position.x, this.position.y);
        }
        
        takeDamage(){
            this.health--;
            if(this.health <= 0) {
                this.explode(null);
            }
        }

        explode(opponent) {
            if(opponent){
                opponent.takeDamage(200);
            }
            createParticleEffect(null, 'pumpkin_explosion', {x: this.position.x + this.width / 2, y: this.position.y + this.height / 2});
            giantBall = null;
        }
    }
    
    class Fighter {
        constructor(x, y, color, name, isPlayer, characterType) {
            this.characterType = characterType;
            this.name = name;
            this.isPlayer = isPlayer;
            this.width = 60;
            this.height = 120;
            this.position = { x, y };
            this.velocity = { x: 0, y: 0 };
            this.color = color;
            this.health = 1000;
            this.energy = 50; 
            this.maxEnergy = 1000;
            this.isJumping = false;
            this.isAttacking = false;
            this.attackBox = { position: {x: 0, y: 0}, width: 0, height: 0, type: null, active: false, hit: false };
            this.attackCooldown = 0;
            this.direction = (x < canvasWidth / 2) ? 1 : -1;
            this.keys = { left: false, right: false, up: false, down: false };
            
            this.lastTap = { key: null, time: 0 };
            this.doubleTapped = false;
            
            this.aiVelocityX = 0;
            // Status Effects
            this.burnDuration = 0;
            this.burnTick = 0;
            this.curseStacks = 0;
            this.curseDuration = 0;
            this.curseTick = 0;
            this.cursedBy = null;
            this.bleedStacks = 0;
            this.bleedDuration = 0;
            this.bleedTick = 0;
            this.bleedPunchCounter = 0;
            
            // Defense
            this.isPreparingDefense = false;
            this.defenseActivationTimer = 0;
            this.isDefending = false;
            this.defenseHealth = 50; 
            this.defenseResetCooldown = 0;
            this.isParalyzed = false;
            this.paralysisTimer = 0;

            // Character-Specific Mechanics
            this.isChannelingSpecial = false;
            this.channelingTick = 0;
            this.channelingDamage = 1;
            this.isDashing = false;
            this.consecutivePunchCounter = 0;
            this.attackSpeedMultiplier = 1;
            this.ryuComboTimer = 0;
            this.ballCount = (this.characterType === 'lorenzo') ? 1 : 0;
            this.maxBallCount = 5;
            this.isWaterfowlDancing = false;
            this.waterfowlHitCount = 0;
        }

        draw() {
            ctx.save();
            ctx.translate(this.position.x, this.position.y);
            if (this.direction === -1) {
                ctx.scale(-1, 1);
                ctx.translate(-this.width, 0);
            }

            if (this.characterType === 'titan') drawTitanArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'spark') drawSparkArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'hades') drawHadesArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'jack') drawJackArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'genji') drawGenjiArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'ryu') drawRyuArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'lorenzo') drawDonLorenzoArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'malenia') drawMaleniaArt(ctx, 0, 0, this.width, this.height, this);
            else if (this.characterType === 'maliketh') drawMalikethArt(ctx, 0, 0, this.width, this.height, this);
            
            ctx.restore();

             // Efeitos Visuais de Status
            if (this.isDefending) {
                ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(this.position.x + this.width / 2, this.position.y + this.height / 2, this.width, 0, Math.PI * 2);
                ctx.fill();
            }

            if(this.isParalyzed) {
                ctx.font = '40px sans-serif';
                ctx.fillText('üí´', this.position.x + this.width / 4, this.position.y - 10);
            }
        }

        update(opponent) {
            if(this.isWaterfowlDancing) {
                const dashSpeed = 15 * this.direction;
                this.position.x += dashSpeed;
                createParticleEffect(this, 'sword_slash');
                if(isColliding(this, opponent) && !this.attackBox.hit) {
                    opponent.isParalyzed = true;
                    opponent.paralysisTimer = 10;
                    opponent.takeDamage(20);
                    this.health = Math.min(1000, this.health + 6);
                    this.waterfowlHitCount++;
                    this.attackBox.hit = true; 
                    setTimeout(() => { this.attackBox.hit = false; }, 10);
                }
                if (this.waterfowlHitCount >= 7 || Math.abs(this.position.x - this.dashStartX) >= canvasWidth / 1.5) {
                    this.isWaterfowlDancing = false;
                    opponent.isParalyzed = false;
                }
                return;
            }

            this.direction = (opponent.position.x > this.position.x) ? 1 : -1;
            
            if(this.isParalyzed){
                this.paralysisTimer--;
                if(this.paralysisTimer <= 0) {
                    this.isParalyzed = false;
                }
                return; 
            }
            
            if(this.isDashing){
                const dashSpeed = 20 * this.direction;
                this.position.x += dashSpeed;
                createParticleEffect(this, 'dash_fire');
                if(isColliding(this, opponent)) {
                    opponent.velocity.y = -20;
                    opponent.takeDamage(50);
                    createParticleEffect(opponent, 'ground_explosion', {x: opponent.position.x, y: opponent.position.y + opponent.height, count: 20, color: 'orange'});
                    this.isDashing = false;
                }
                if(Math.abs(this.position.x - this.dashStartX) >= canvasWidth / 2) {
                    this.isDashing = false;
                }
                return;
            }

            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;

            if (this.position.y + this.height + this.velocity.y < floorY) {
                this.velocity.y += gravity;
                this.isJumping = true;
            } else {
                this.velocity.y = 0;
                this.position.y = floorY - this.height;
                this.isJumping = false;
            }

            if (this.position.x < 0) this.position.x = 0;
            if (this.position.x + this.width > canvasWidth) this.position.x = canvasWidth - this.width;

            this.velocity.x = 0;
            if (this.isPlayer && !this.isAttacking && !this.isDefending) {
                if (this.keys.left) this.velocity.x = -5;
                if (this.keys.right) this.velocity.x = 5;
            } else if (!this.isPlayer) {
                this.velocity.x = this.aiVelocityX;
            }
            
            if (this.attackCooldown > 0) {
                this.attackCooldown--;
            } else {
                this.isAttacking = false;
                this.attackBox.active = false;
                this.attackBox.hit = false;
            }

            if (this.attackBox.active) {
                this.attackBox.position.x = this.position.x + (this.direction === 1 ? this.width : -this.attackBox.width);
                this.attackBox.position.y = this.position.y + this.height / 3;
            }
            
            if(this.isPreparingDefense && !this.isDefending) {
                this.defenseActivationTimer--;
                if(this.defenseActivationTimer <= 0) {
                    this.isDefending = true;
                }
            }

            if (this.defenseResetCooldown > 0) {
                this.defenseResetCooldown--;
                if (this.defenseResetCooldown <= 0) {
                    this.defenseHealth = 50; 
                }
            }
            
            if (this.characterType === 'ryu' && this.ryuComboTimer > 0) {
                this.ryuComboTimer--;
                if (this.ryuComboTimer <= 0) {
                    this.consecutivePunchCounter = 0;
                    this.attackSpeedMultiplier = 1;
                }
            }
            
            this.handleStatusEffects(opponent);
            if(this.characterType === 'spark') {
                this.handleSparkSpecial(opponent);
            }
            
            // Regenera√ß√£o de energia
            this.energy = Math.min(this.maxEnergy, this.energy + 0.5);
        }
        
        handleStatusEffects(opponent){
            if (this.burnDuration > 0) {
                this.burnDuration--;
                this.burnTick++;
                if (this.burnTick >= 60) {
                    this.health -= 9;
                    this.burnTick = 0;
                    particles.push(new Particle(this.position.x + Math.random() * this.width, this.position.y + Math.random() * this.height, 'orange', 0));
                }
            }
            
            if (this.curseDuration > 0) {
                this.curseDuration--;
                this.curseTick++;
                if (this.curseTick >= 60) {
                    if (this.cursedBy) {
                        this.health -= 9 * this.curseStacks;
                        this.cursedBy.health = Math.min(1000, this.cursedBy.health + (5 * this.curseStacks));
                        particles.push(new Particle(this.position.x + Math.random() * this.width, this.position.y + Math.random() * this.height, 'purple', 0));
                    }
                    this.curseTick = 0;
                }
                if (this.curseDuration === 0) {
                    this.curseStacks = 0;
                    this.cursedBy = null;
                }
            }
            
            if (this.bleedDuration > 0) {
                this.bleedDuration--;
                this.bleedTick++;
                if (this.bleedTick >= 60) {
                    this.health -= 8 * this.bleedStacks;
                    this.bleedTick = 0;
                    particles.push(new Particle(this.position.x + Math.random() * this.width, this.position.y + Math.random() * this.height, 'red', 0));
                }
                 if(this.bleedDuration === 0) {
                    this.bleedStacks = 0;
                }
            }
        }
        
        handleSparkSpecial(opponent) {
            if (!this.isChannelingSpecial) {
                return;
            }

            if (this.energy > 0) {
                this.channelingTick++;
                
                if (this.channelingTick % 15 === 0) {
                    this.energy -= 1;
                }
                
                if (this.channelingTick > 0 && this.channelingTick % 60 === 0) {
                    opponent.takeDamage(this.channelingDamage);
                    this.channelingDamage *= 2;
                }
                 sounds.spark.special.triggerAttackRelease("8n");

            } else {
                this.isChannelingSpecial = false;
                this.channelingDamage = 1;
                this.channelingTick = 0;
            }
        }
        
        applyCurse(attacker) {
            this.cursedBy = attacker;
            this.curseStacks = Math.min(8, this.curseStacks + 1);
            this.curseDuration = 300; // 5 segundos
        }

        takeDamage(damage, effect = {}) {
            if (this.isDefending) {
                const effectiveDamage = (this.characterType === 'spark' || this.characterType === 'titan') ? damage * 0.5 : damage; 
                this.defenseHealth -= effectiveDamage;
                this.position.x -= this.direction * 15;
                if (this.defenseHealth <= 0) {
                    this.isDefending = false;
                    this.isPreparingDefense = false;
                    this.isParalyzed = true;
                    this.paralysisTimer = 180;
                    this.defenseResetCooldown = 120;
                    sounds.defenseBreak.triggerAttackRelease("C3", "8n");
                }
                return true;
            }
            
            this.health -= damage;
            if (effect.type === 'burn') { this.burnDuration = 180; }
            if (effect.type === 'curse') { this.applyCurse(effect.attacker); }
            if (effect.type === 'bleed') {
                this.bleedStacks = Math.min(3, this.bleedStacks + 1);
                this.bleedDuration = 240; // 4 segundos
            }
            if (this.health < 0) this.health = 0;
            
            return false;
        }

        attack(type) {
            if (this.attackCooldown > 0 || this.isParalyzed || this.isDefending || this.isDashing || this.isWaterfowlDancing) return;
            
            this.isAttacking = true;
            this.attackBox.type = type;

            switch(type) {
                case 'punch':
                    if (this.characterType === 'lorenzo' && this.ballCount <= 0) { this.isAttacking = false; return; }
                    
                    if (this.characterType === 'jack' || this.characterType === 'malenia' || this.characterType === 'maliketh') {
                        this.attackCooldown = 30;
                        this.attackBox.active = true;
                        this.attackBox.width = 90; // L√¢mina maior
                        this.attackBox.height = 30;
                        sounds.jack.punch.triggerAttackRelease("E3", "8n");
                    } else {
                        this.attackCooldown = 20 / this.attackSpeedMultiplier;
                        this.attackBox.active = true;
                        this.attackBox.width = 70;
                        this.attackBox.height = 30;
                        if (this.characterType === 'spark') sounds.spark.punch.triggerAttackRelease("C5", "8n");
                        else if (this.characterType === 'titan') sounds.titan.punch.triggerAttackRelease(200, "8n");
                        else if (this.characterType === 'hades') sounds.hades.punch.triggerAttackRelease("A2", "8n");
                        else if (this.characterType === 'genji') sounds.genji.punch.triggerAttackRelease("G4", "16n");
                        else if (this.characterType === 'ryu') sounds.ryu.punch.triggerAttackRelease("C4", "16n");
                        else if (this.characterType === 'lorenzo') {
                            this.ballCount--;
                            const projectileY = this.position.y + this.height / 2;
                            const projectileX = this.position.x + (this.direction === 1 ? this.width : -40);
                            projectiles.push(new Projectile(projectileX, projectileY, this.direction, this, 'football', 10));
                        }
                    }
                    break;
                case 'strong_punch':
                    this.attackCooldown = 45;
                    this.attackBox.active = true;
                    this.attackBox.width = 90;
                    this.attackBox.height = 40;
                    if (this.characterType === 'spark') sounds.spark.strong_punch.triggerAttackRelease("C4", "4n");
                    else if (this.characterType === 'titan') sounds.titan.strong_punch.triggerAttackRelease(150, "4n");
                    else if (this.characterType === 'hades') sounds.hades.strong_punch.triggerAttackRelease("A1", "4n");
                    else if (this.characterType === 'jack') sounds.jack.strong_punch.triggerAttackRelease("E2", "4n");
                    else if (this.characterType === 'genji') sounds.genji.strong_punch.triggerAttackRelease("G3", "4n");
                     else if (this.characterType === 'ryu') sounds.ryu.strong_punch.triggerAttackRelease("C3", "4n");
                    break;
                case 'special':
                    if (this.characterType === 'spark') {
                        return;
                    }
                    const energyCost = (this.characterType === 'malenia' || this.characterType === 'maliketh') ? 300 : (this.characterType === 'lorenzo') ? 400 : (this.characterType === 'genji' || this.characterType === 'ryu' ? 100 : 45);
                    if (this.energy < energyCost) { this.isAttacking = false; return; }
                    this.energy -= energyCost;
                    this.attackCooldown = 60;
                    
                    const projectileY = this.position.y + this.height / 3;
                    const projectileX = this.position.x + (this.direction === 1 ? this.width : -40);
                    
                    if (this.characterType === 'titan') {
                        sounds.titan.special.triggerAttackRelease("2n");
                        projectiles.push(new Projectile(projectileX, projectileY, this.direction, this, 'rocket_punch', 30));
                        createParticleEffect(this, 'special');
                    } else if (this.characterType === 'hades') {
                        sounds.hades.special.triggerAttackRelease("2n");
                        const opponent = this.isPlayer ? player2 : player1;
                        opponent.takeDamage(70, {type: 'burn'});
                        createParticleEffect(opponent, 'ground_explosion', {x: opponent.position.x, y: opponent.position.y + opponent.height, count: 20});
                    } else if (this.characterType === 'jack') {
                         sounds.jack.special.triggerAttackRelease("C3", "2n");
                        projectiles.push(new Projectile(projectileX, projectileY, this.direction, this, 'pumpkin', 30));
                    } else if (this.characterType === 'genji') {
                        sounds.genji.special.triggerAttackRelease("2n");
                        projectiles.push(new Projectile(projectileX, projectileY, this.direction, this, 'tornado', 70));
                    } else if (this.characterType === 'ryu') {
                         sounds.ryu.special.triggerAttackRelease("1n");
                         this.isDashing = true;
                         this.dashStartX = this.position.x;
                    } else if (this.characterType === 'lorenzo') {
                        if(this.ballCount < this.maxBallCount) {
                             this.ballCount++;
                        }
                        this.isAttacking = false;
                    } else if (this.characterType === 'malenia') {
                        this.isWaterfowlDancing = true;
                        this.waterfowlHitCount = 0;
                        this.dashStartX = this.position.x;
                    } else if (this.characterType === 'maliketh') {
                        this.velocity.y = -20;
                        setTimeout(() => {
                            for(let i=0; i<5; i++){
                                setTimeout(() => {
                                    const opponent = this.isPlayer ? player2 : player1;
                                    const angle = Math.atan2(opponent.position.y - this.position.y, opponent.position.x - this.position.x);
                                    const speed = 8;
                                    const p = new Projectile(this.position.x, this.position.y, this.direction, this, 'maliketh_blade', 70);
                                    p.velocity.x = Math.cos(angle) * speed;
                                    p.velocity.y = Math.sin(angle) * speed;
                                    projectiles.push(p);
                                }, i * 200);
                            }
                        }, 500);
                    }
                    break;
            }
        }
    }

    function createParticleEffect(fighter, type, extraParams = {}) {
        let count = 0;
        let color = extraParams.color || 'orange';
        
        if (type === 'special' && fighter && fighter.characterType === 'titan') {
            color = 'rgba(255, 100, 0, 0.8)';
            count = 15;
        } else if (type === 'pumpkin_explosion') {
            color = 'rgba(255, 100, 0, 0.8)';
            count = 30;
        } else if (type === 'ground_explosion') {
            count = extraParams.count || 20;
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(
                    extraParams.x + (Math.random() - 0.5) * (fighter ? fighter.width : 50),
                    extraParams.y,
                    'hades_fire', 
                    0,
                    { x: (Math.random() - 0.5) * 2, y: - (Math.random() * 6 + 3) }
                ));
            }
            return;
        } else if (type === 'dash_fire') {
            particles.push(new Particle(fighter.position.x + fighter.width/2, fighter.position.y + fighter.height/2, 'red', 0, { x: -fighter.direction * 3, y: (Math.random() - 0.5) * 2 }));
            return;
        } else if (type === 'ryu_punch') {
            count = extraParams.count || 1;
             for (let i = 0; i < count; i++) {
                particles.push(new Particle( extraParams.x, extraParams.y, 'ryu_star', 0, { x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5 }));
             }
             return;
        } else if (type === 'sword_slash') {
             particles.push(new Particle(fighter.position.x + fighter.width/2, fighter.position.y + fighter.height/2, '#c0c0c0', 0, { x: fighter.direction * 5, y: (Math.random() - 0.5) * 5 }));
             return;
        }

        for (let i = 0; i < count; i++) {
            particles.push(new Particle(
                extraParams.x || (fighter.position.x + fighter.width / 2),
                extraParams.y || (fighter.position.y + fighter.height / 2),
                color,
                fighter.direction
            ));
        }
    }

    class Particle {
        constructor(x, y, color, direction, customVelocity) {
            this.position = { x, y };
            this.velocity = customVelocity || { 
                x: (Math.random() - 0.5) * 8, 
                y: (Math.random() - 0.5) * 8 
            };
            this.radius = Math.random() * 4 + 2;
            this.color = color;
            this.life = 100;
        }

        draw() {
             if(this.color === 'hades_fire') {
                ctx.font = `${this.radius * 6}px sans-serif`;
                ctx.fillText('üî•', this.position.x, this.position.y);
            } else if(this.color === 'ryu_star') {
                ctx.font = `${this.radius * 4}px sans-serif`;
                ctx.fillText('‚ú®', this.position.x, this.position.y);
            }
            else {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        update() {
            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;
            this.life -= 3;
        }
    }

    class AI {
        constructor(fighter, opponent) {
            this.fighter = fighter;
            this.opponent = opponent;
            this.state = 'IDLE';
            this.decisionInterval = null;
        }

        start() {
            this.decisionInterval = setInterval(() => this.makeDecision(), 300); // A IA toma decis√µes mais r√°pido
        }

        stop() {
            if (this.decisionInterval) clearInterval(this.decisionInterval);
            this.fighter.aiVelocityX = 0;
        }
        
        makeDecision() {
            if (gameState !== 'FIGHT' || this.fighter.isParalyzed) return;

            const distance = Math.abs(this.fighter.position.x - this.opponent.position.x);
            const canUseSpecial = this.fighter.energy >= 45;
            
            this.fighter.aiVelocityX = 0;
            this.fighter.isDefending = false;

            // A√ß√£o defensiva (menos prov√°vel)
            if (this.opponent.isAttacking && distance < 150 && Math.random() < 0.5 && this.fighter.defenseResetCooldown <= 0) {
                this.fighter.isDefending = true;
                return;
            }

            // A√ß√µes ofensivas (mais prov√°veis)
            if (canUseSpecial && distance < 300 && Math.random() < 0.7) {
                this.fighter.attack('special');
                return;
            } 
            
            if (distance < 100 && Math.random() < 0.9) {
                 this.fighter.attack('punch');
                 return;
            }

            // Se n√£o atacar, move-se em dire√ß√£o ao jogador
            if (!this.fighter.isAttacking) {
                this.fighter.aiVelocityX = this.fighter.direction * 3;
            }
        }
    }

    let aiController;

    function isColliding(rect1, rect2) {
        return (
            rect1.position.x < rect2.position.x + rect2.width &&
            rect1.position.x + rect1.width > rect2.position.x &&
            rect1.position.y < rect2.position.y + rect2.height &&
            rect1.position.y + rect1.height > rect2.position.y
        );
    }
    
    function updateHUD() {
        if (!player1 || !player2) return;
        document.getElementById('p1-name').innerText = player1.name;
        document.getElementById('p1-health').style.width = (player1.health / 1000) * 100 + '%';
        document.getElementById('p1-energy').style.width = (player1.energy / 1000) * 100 + '%';
        document.getElementById('p1-health-text').innerText = `${Math.ceil(player1.health)} / 1000`;
        document.getElementById('p1-energy-text').innerText = `${Math.ceil(player1.energy)} / 1000`;
        updateStatusIcons(player1, document.getElementById('p1-status-effects'));
        
        document.getElementById('p2-name').innerText = player2.name;
        document.getElementById('p2-health').style.width = (player2.health / 1000) * 100 + '%';
        document.getElementById('p2-energy').style.width = (player2.energy / 1000) * 100 + '%';
        document.getElementById('p2-health-text').innerText = `${Math.ceil(player2.health)} / 1000`;
        document.getElementById('p2-energy-text').innerText = `${Math.ceil(player2.energy)} / 1000`;
        updateStatusIcons(player2, document.getElementById('p2-status-effects'));
    }

    function updateStatusIcons(player, container) {
        container.innerHTML = '';
        if (player.bleedStacks > 0) {
            const bleedIcon = document.createElement('span');
            bleedIcon.className = 'status-icon';
            bleedIcon.innerHTML = `ü©∏<span class="stack-count">${player.bleedStacks}</span>`;
            container.appendChild(bleedIcon);
        }
        if (player.burnDuration > 0) {
            const burnIcon = document.createElement('span');
            burnIcon.className = 'status-icon';
            burnIcon.innerText = 'üåã';
            container.appendChild(burnIcon);
        }
        if (player.curseStacks > 0) {
             const curseIcon = document.createElement('span');
            curseIcon.className = 'status-icon';
            curseIcon.innerHTML = `üíÄ<span class="stack-count">${player.curseStacks}</span>`;
            container.appendChild(curseIcon);
        }
         if (player.characterType === 'ryu' && player.attackSpeedMultiplier > 1) {
            const speedIcon = document.createElement('span');
            speedIcon.className = 'status-icon';
            speedIcon.innerHTML = `‚ú®<span class="stack-count">x${player.attackSpeedMultiplier.toFixed(1)}</span>`;
            container.appendChild(speedIcon);
        }
        if (player.characterType === 'lorenzo') {
            const ballIcon = document.createElement('span');
            ballIcon.className = 'status-icon';
            ballIcon.innerHTML = `‚öΩÔ∏è<span class="stack-count">${player.ballCount}</span>`;
            container.appendChild(ballIcon);
        }
    }

    function checkGameOver() {
        if (!player1 || !player2) return;
        if (player1.health <= 0 || player2.health <= 0) {
            gameState = 'GAMEOVER';
            aiController.stop();
            cancelAnimationFrame(gameLoopId);
            gameOverScreen.classList.remove('hidden');
            
            const winner = player1.health > 0 ? player1 : player2;
            winText.innerText = `${winner.name.toUpperCase()} WINS!`;
            
            startWinnerZoom(winner);
        }
    }
    
    let zoomFactor = 1;
    let winnerToZoom = null;
    let zoomLoopId = null;
    function startWinnerZoom(winner) {
        winnerToZoom = winner;
        zoomFactor = 1;
        
        function zoomLoop() {
            if (zoomFactor > 2.5) {
                 winnerToZoom = null;
                 cancelAnimationFrame(zoomLoopId);
                 return;
            }
            zoomFactor += 0.01;
            
            draw();
            
            ctx.save();
            ctx.translate(winnerToZoom.position.x + winnerToZoom.width/2, winnerToZoom.position.y + winnerToZoom.height/2);
            ctx.scale(zoomFactor, zoomFactor);
            ctx.translate(-(winnerToZoom.position.x + winnerToZoom.width/2), -(winnerToZoom.position.y + winnerToZoom.height/2));
            winnerToZoom.draw();
            ctx.restore();
            
            zoomLoopId = requestAnimationFrame(zoomLoop);
        }
        zoomLoop();
    }

    function drawBackground() {
        const skyGradient = ctx.createLinearGradient(0, 0, 0, floorY);
        skyGradient.addColorStop(0, '#1c1c2c');
        skyGradient.addColorStop(1, '#3a3a5a');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, canvasWidth, floorY);

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 15; j++) {
                ctx.fillStyle = `rgba(50, 50, 70, ${0.5 - i * 0.1})`;
                const x = j * (canvasWidth / 14);
                const h = (Math.random() * 200 + 100) / (i + 1);
                ctx.fillRect(x, floorY - h, canvasWidth / 15, h);
            }
        }
        
        ctx.fillStyle = '#333';
        ctx.fillRect(0, floorY, canvasWidth, canvasHeight - floorY);
        
        const gateWidth = canvasWidth * 0.3;
        const gateHeight = canvasHeight * 0.6;
        const gateX = canvasWidth / 2 - gateWidth / 2;
        const gateY = floorY - gateHeight;
        
        ctx.fillStyle = '#c0392b';
        ctx.fillRect(gateX, gateY, 30, gateHeight);
        ctx.fillRect(gateX + gateWidth - 30, gateY, 30, gateHeight);
        ctx.beginPath();
        ctx.moveTo(gateX - 20, gateY + 20);
        ctx.lineTo(gateX + gateWidth + 20, gateY + 20);
        ctx.lineTo(gateX + gateWidth, gateY);
        ctx.lineTo(gateX, gateY);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#333';
        ctx.fillRect(gateX, gateY - 10, gateWidth, 10);
    }
    
    function handleFighterCollision() {
        if (!player1 || !player2) return;

        const p1Bottom = player1.position.y + player1.height;
        const p2Bottom = player2.position.y + player2.height;

        if (p1Bottom > player2.position.y && player1.position.y < p2Bottom) {
             const dx = (player1.position.x + player1.width / 2) - (player2.position.x + player2.width / 2);
            const combinedHalfWidths = player1.width / 2 + player2.width / 2;
            const overlapX = combinedHalfWidths - Math.abs(dx);

            if (overlapX > 0) {
                const pushback = overlapX / 2;
                if (dx > 0) {
                    player1.position.x += pushback;
                    player2.position.x -= pushback;
                } else {
                    player1.position.x -= pushback;
                    player2.position.x += pushback;
                }
            }
        }
    }
    
    function checkMeleeCollision(attacker, defender) {
        if (!attacker.attackBox.active || attacker.attackBox.hit) return;

        if (isColliding(attacker.attackBox, defender)) {
            let damage = 0;
            let effect = {};
            switch(attacker.attackBox.type) {
                case 'punch':
                    damage = (attacker.characterType === 'malenia') ? 9 : 10;
                    if(attacker.characterType === 'malenia') {
                        attacker.health = Math.min(1000, attacker.health + 6);
                    }
                    if (attacker.characterType === 'hades') { effect.type = 'burn';}
                    if (attacker.characterType === 'jack') {
                        attacker.cursePunchCounter++;
                        if (attacker.cursePunchCounter >= 2) {
                            defender.applyCurse(attacker);
                            attacker.cursePunchCounter = 0;
                        }
                    }
                     if (attacker.characterType === 'genji') {
                        attacker.bleedPunchCounter++;
                        if (attacker.bleedPunchCounter >= 4) {
                            effect.type = 'bleed';
                            attacker.bleedPunchCounter = 0;
                        }
                    }
                    if (attacker.characterType === 'ryu') {
                         attacker.consecutivePunchCounter++;
                         attacker.attackSpeedMultiplier = Math.min(7, 1 + (attacker.consecutivePunchCounter-1));
                         attacker.ryuComboTimer = 120; // 2 segundos
                         createParticleEffect(defender, 'ryu_punch', {x: defender.position.x + defender.width/2, y: defender.position.y + defender.height/2, count: attacker.consecutivePunchCounter});
                    }
                    break;
                case 'strong_punch':
                    damage = 25;
                     if (attacker.characterType === 'hades') { effect.type = 'burn'; }
                     if (attacker.characterType === 'jack') { defender.applyCurse(attacker); }
                    break;
            }

            const defended = defender.takeDamage(damage, effect);
            if(defended) {
                 attacker.energy = Math.min(1000, attacker.energy + 7.5);
            } else if (damage > 0) {
                attacker.energy = Math.min(1000, attacker.energy + 15);
            }
            attacker.attackBox.hit = true; 
        }
    }


    function gameLoop() {
        if (gameState !== 'FIGHT') return;

        gameLoopId = requestAnimationFrame(gameLoop);
        
        if (player1) player1.update(player2);
        if (player2) player2.update(player1);
        
        if (!giantBall) {
            handleFighterCollision(); 
        }

        particles.forEach((p, index) => {
            p.update();
            if(p.life <= 0) particles.splice(index, 1);
        });

        projectiles.forEach((projectile, index) => {
            projectile.update();
            const target = projectile.shooter === player1 ? player2 : player1;
            
            if (!projectile.hitTargets.includes(target) && isColliding(projectile, target)) {
                
                if (projectile.type === 'tornado' && !target.isDefending) {
                    projectile.shooter.isSpecialAttacking = true;
                    target.isParalyzed = true; 
                    
                    const teleportX = target.position.x - projectile.shooter.width;
                    projectile.shooter.position.x = teleportX;
                    
                    projectile.shooter.velocity.y = -20;
                    target.velocity.y = -20;
                    
                    setTimeout(() => {
                        target.takeDamage(projectile.damage);
                        projectile.shooter.isSpecialAttacking = false;
                        target.isParalyzed = false;
                    }, 500);
                    projectiles.splice(index, 1);
                    return;

                } else if (projectile.type !== 'tornado' || target.isDefending) {
                     target.takeDamage(projectile.damage);
                }
               
                if(projectile.type === 'pumpkin'){
                    target.applyCurse(projectile.shooter);
                    projectiles.splice(index, 1);
                } else if (projectile.type === 'football') {
                     projectile.velocity.x *= -0.7; 
                     projectile.isReturning = true;
                     projectile.hitTargets.push(target);
                }
                
                if(projectile.type !== 'football'){
                    projectiles.splice(index, 1);
                }
                return;
            }
            
            if (projectile.type === 'football' && projectile.isReturning && isColliding(projectile, projectile.shooter)) {
                projectile.shooter.ballCount++;
                projectiles.splice(index, 1);
                return;
            }

             if (projectile.position.x + projectile.width > canvasWidth || projectile.position.x < 0) {
                if (projectile.type === 'football') {
                    if (!projectile.isReturning) {
                        groundFootball = { position: { ...projectile.position }, width: projectile.width, height: projectile.height };
                        projectiles.splice(index, 1);
                    } else {
                        projectile.velocity.x *= -1; // Ricocheteia ao voltar
                    }
                } else {
                    projectiles.splice(index, 1);
                }
            }
        });

        if (groundFootball && isColliding(player1, groundFootball)) {
            player1.ballCount++;
            groundFootball = null;
        }

        checkMeleeCollision(player1, player2);
        checkMeleeCollision(player2, player1);

        if(giantBall) {
            const opponent = giantBall.owner === player1 ? player2 : player1;
            giantBall.update(opponent);
            if(giantBall && opponent.attackBox.active && !opponent.attackBox.hit && isColliding(opponent.attackBox, giantBall)) {
                giantBall.takeDamage();
                opponent.attackBox.hit = true;
            }
        }
        
        draw();
        updateHUD();
        checkGameOver();
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        drawBackground();
        if (player1) player1.draw();
        if (player2) player2.draw();
        
        if(player1 && player1.isChannelingSpecial) drawLightningChain(player1, player2);
        if(player2 && player2.isChannelingSpecial) drawLightningChain(player2, player1);

        particles.forEach(p => p.draw());
        projectiles.forEach(p => p.draw());
        if(giantBall) giantBall.draw();
        if(groundFootball) {
            ctx.font = `40px sans-serif`;
            ctx.fillText('‚öΩÔ∏è', groundFootball.position.x, groundFootball.position.y + groundFootball.height);
        }
    }

    function drawLightningChain(attacker, defender) {
        const startX = attacker.position.x + attacker.width / 2;
        const startY = attacker.position.y + attacker.height / 2;
        const endX = defender.position.x + defender.width / 2;
        const endY = defender.position.y + defender.height / 2;

        const dx = endX - startX;
        const dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const segments = Math.floor(distance / 20);

        ctx.font = '20px sans-serif';

        for(let i = 1; i < segments; i++) {
            const t = i / segments;
            const x = startX + dx * t + (Math.random() - 0.5) * 10;
            const y = startY + dy * t + (Math.random() - 0.5) * 10;
            ctx.fillText('‚ö°Ô∏è', x, y);
        }
    }
    
    // --- Controles de Eventos ---
    window.addEventListener('keydown', (e) => {
        if (gameState !== 'FIGHT' || !player1 || !player1.isPlayer) return;

        const key = e.key.toLowerCase();
        const now = Date.now();

        switch (key) {
            case 'a':
                player1.keys.left = true;
                if (player1.direction === -1) { 
                    if (player1.lastTap.key === 'a' && now - player1.lastTap.time < 300) {
                        player1.doubleTapped = true;
                        player1.lastTap.key = null;
                        setTimeout(() => { if(player1) player1.doubleTapped = false; }, 300);
                    }
                }
                player1.lastTap = { key: 'a', time: now };
                break;
            case 'd':
                player1.keys.right = true;
                if (player1.direction === 1) {
                    if (player1.lastTap.key === 'd' && now - player1.lastTap.time < 300) {
                        player1.doubleTapped = true;
                        player1.lastTap.key = null;
                        setTimeout(() => { if(player1) player1.doubleTapped = false; }, 300);
                    }
                }
                player1.lastTap = { key: 'd', time: now };
                break;
            case ' ': // Espa√ßo para pular
                if (!player1.isJumping) {
                    player1.velocity.y = -20;
                    player1.isJumping = true;
                }
                break;
            case 's':
                if(!player1.isDefending && !player1.isParalyzed && player1.defenseResetCooldown <= 0) {
                    player1.isPreparingDefense = true;
                    player1.defenseActivationTimer = 30; // 0.5s
                }
                break;
        }

        switch(key) {
            case 'arrowleft':
                if (player1.doubleTapped) {
                    player1.attack('strong_punch');
                } else {
                    player1.attack('punch');
                }
                player1.doubleTapped = false;
                break;
            case 'arrowright':
                if (player1.characterType === 'spark') {
                    player1.isChannelingSpecial = true;
                } else {
                    player1.attack('special');
                }
                player1.doubleTapped = false;
                break;
        }
    });

    window.addEventListener('keyup', (e) => {
        if (gameState !== 'FIGHT' || !player1 || !player1.isPlayer) return;

        switch (e.key.toLowerCase()) {
            case 'a': player1.keys.left = false; break;
            case 'd': player1.keys.right = false; break;
            case 's':
                player1.isPreparingDefense = false;
                if(player1.isDefending) {
                    player1.defenseResetCooldown = 120; // 2s cooldown
                }
                player1.isDefending = false;
                break;
            case 'arrowright':
                 if (player1.characterType === 'spark') {
                    player1.isChannelingSpecial = false;
                    player1.channelingDamage = 1;
                    player1.channelingTick = 0;
                }
                break;
        }
    });
    
    // --- L√≥gica da Tela de Sele√ß√£o (Restaurada) ---
    function setupSelectionScreen() {
        drawThumbnails();
        document.querySelectorAll('.character-card').forEach(card => {
            card.addEventListener('click', () => {
                startGame(card.id.replace('select-', ''));
            });
            const loreTooltip = document.getElementById('lore-tooltip');
            card.addEventListener('mouseenter', (e) => {
                loreTooltip.innerText = e.currentTarget.dataset.lore;
                loreTooltip.style.display = 'block';
            });
            card.addEventListener('mouseleave', () => {
                loreTooltip.style.display = 'none';
            });
            card.addEventListener('mousemove', (e) => {
                const gameContainerRect = gameContainer.getBoundingClientRect();
                loreTooltip.style.left = `${e.clientX - gameContainerRect.left + 15}px`;
                loreTooltip.style.top = `${e.clientY - gameContainerRect.top - loreTooltip.offsetHeight - 5}px`;
            });
        });
    }

    // --- In√≠cio do Jogo ---
    async function startGame(playerChoice) {
        try {
            await Tone.start();
            console.log("Contexto de √°udio iniciado.");
        } catch(e) {
            console.error("Erro ao iniciar √°udio", e);
        }

        selectionScreen.classList.add('hidden');
        loadingScreen.classList.remove('hidden');
        backgroundLayer.style.display = 'block';
        canvas.style.backgroundColor = 'transparent';

        setTimeout(() => {
            loadingScreen.classList.add('hidden');
            const characters = [
                { id: 'titan', name: 'Titan', type: 'titan' },
                { id: 'spark', name: 'Spark', type: 'spark' },
                { id: 'hades', name: 'Hades', type: 'hades' },
                { id: 'jack', name: 'Jack', type: 'jack' },
                { id: 'genji', name: 'Genji', type: 'genji' },
                { id: 'ryu', name: 'Ryu', type: 'ryu' },
                { id: 'lorenzo', name: 'Don Lorenzo', type: 'lorenzo' },
                { id: 'malenia', name: 'Malenia', type: 'malenia' },
                { id: 'maliketh', name: 'Maliketh', type: 'maliketh' }
            ];

            const playerConfig = characters.find(c => c.id === playerChoice);
            const opponentPool = characters.filter(c => c.id !== playerChoice);
            const opponentConfig = opponentPool[Math.floor(Math.random() * opponentPool.length)];

            player1 = new Fighter(canvasWidth * 0.2, floorY - 120, {}, playerConfig.name, true, playerConfig.type);
            player2 = new Fighter(canvasWidth * 0.8 - 50, floorY - 120, {}, opponentConfig.name, false, opponentConfig.type);
            
            aiController = new AI(player2, player1);
            aiController.start();
    
            gameState = 'FIGHT';
            gameLoop();
        }, 5000);
    }
    
    function resetGame() {
        cancelAnimationFrame(gameLoopId);
        cancelAnimationFrame(zoomLoopId);
        if(aiController) aiController.stop();

        selectionScreen.classList.remove('hidden');
        gameOverScreen.classList.add('hidden');
        backgroundLayer.style.display = 'none';
        canvas.style.backgroundColor = 'var(--background-dark)';
        
        player1 = null;
        player2 = null;

        particles = [];
        projectiles = []; 
        giantBall = null; 
        gameState = 'SELECT';
        ctx.clearRect(0,0,canvasWidth, canvasHeight);
        drawBackground();
    }
    
    restartButton.addEventListener('click', resetGame);
    drawBackground();
    setupSelectionScreen();

};
</script>
</body>
</html>
